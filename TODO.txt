Das werden die Benchmarks (ocl_mem, ocl_vecadd, ocl_events) schwarz auf weiß belegen.

Architektur & Design
1. Lifetime Management

DeviceBuffer<'ctx, T, S> hat 'ctx Lifetime, wird aber oft 'static verwendet
Könnte vereinfacht werden oder konsistenter genutzt werden


5. Dokumentation

Viele Funktionen haben keine/wenig Dokumentation
Type-State Pattern könnte besser erklärt werden

6. Unsafe Code

assume_state<Target>() Methode - könnte gefährlich sein
FFI mit kernel.get() as *mut c_void - könnte sauberer sein

Performance & Features
7. Memory Management

Keine explizite Drop-Implementierung für Ressourcen-Cleanup
Buffer-Reuse könnte optimiert werden

8. Missing Features

Kein async/await Support
Keine Buffer-Pooling
Keine Multi-Queue Support


GpuEventGuard::Drop (Letztsicherung)
Optional, aber praxisfreundlich: Im Drop des Guards ein let _ = e.wait(); (best-effort), damit kein Event „offen“ bleibt, falls jemand das Token vergisst. Compile-Time erzwingt ihr das korrekte wait trotzdem über den konsumierenden EventToken. (opencl3 hat explizite wait-APIs.)
Docs.rs

wait-Fehlerbehandlung entscheiden
Aktuell macht ihr effektiv „infallible wait“. Das ist ok (ergonomisch), aber bewusst:

Entweder so lassen und im Guard/Token debug_assert!(wait.is_ok()).

Oder EventToken::wait als -> Result<DeviceBuffer<T, Ready>> signieren und durchreichen.
Beides ist legitim; wählt eine Linie und zieht sie durch. (OpenCL clWaitForEvents kann fehlschlagen.)
registry.khronos.org

From<Event> for GpuEventGuard nur als Helfer
Kann drinbleiben (macht interne Aufrufer bequem), aber verlasst euch nach außen auf from_event/from_guard. So bleibt die API lesbar und konsistent. (Hintergrund: From<T> for U impliziert automatisch Into<U> for T.)
Rust Documentation
+2
Rust Documentation
+2


Ja! Du meinst das Lifetime-Branding zwischen Context, Queue und Buffer!
Das Problem: Aktuell können Buffer und Queues von verschiedenen Contexts gemischt werden:


BUFFER CENTRIC ABSCHAFFEN bei kernelafurf


Fehlerklasse F6 muss noch verbessert werden


Noch offen / zu sichern

Compile-Fail-Belege (EPS)

In tests/compile_fail/ → sicherstellen, dass alle Kernfehlerklassen (F1–F8) drin sind.

Doku/Mapping in SPEC-tests-map.md: jede Regel ↔ Testfall.

Artefakte: Screenshots/Logs von 1–2 Tests für die Demo.

Bug-Injection Crate

crates/bug_injection/ mit Minimal-Baselines (zeigen Fehlverhalten).

Runner, der zählt: #Injected, #Prevented.

PSC-Metrik updaten (z. B. 9/12 = 75 %).

Leak-Report

RAII-Zähler für OpenCL-Objekte.

Aggregierter JSONL-Export unter results/YYYY-MM-DD/leaks/.

Drop-Summary in der Demo zeigen („Leak=0“ im Happy-Path).

Mini-Fuzzer v0

Seeds: VecAdd, Reduction, Scatter/Gather.

Runner mit CLI-Flags.

Output → JSONL unter results/YYYY-MM-DD/fuzzer/.

Cross-Mapping & Related Work

docs/cross_mapping.md: Tabelle (SYCL, CUDA, OpenCL).

docs/related_work.md: 4–6 Quellen, kurze Zusammenfassung.

Paper-Integration

paper/main.md muss IMRaD-Struktur haben.

evaluation.md enthält Bench-Plots + Threats-Section (Varianz, pinned vs. pageable).

Repro-Doku

docs/reproduce.md: Step-by-Step „10 min to snapshot“.

Checksummen der Artefakte + CI-Badge.

Release/Badges

Tag v0.1.0-eps.

GitHub Release mit Assets (Paper PDF, Results, SPEC, Bug-Injection, Benches).

Zenodo DOI eintragen, Badges im README.

